import subprocess
from typing import Any
import docker  # type: ignore[import-untyped]
import docker.errors  # type: ignore[import-untyped]
from docker.models.containers import Container  # type: ignore[import-untyped]

from loguru import logger

from langchain.tools import tool

client = docker.from_env()


def list_docker_containers() -> list[dict[str, Any]] | None:
    """
    List all running docker containers
    """

    containers: list[Container] = client.containers.list()
    result = [{'name': c.name, 'id': c.id} for c in containers]
    logger.debug(f'List docker containers: {result}')
    return result or None


def build_docker_image(
    tag: str,
    path: str,
    dockerfile: str = 'Dockerfile',
    rm: bool = False,
) -> dict[str, Any]:
    """
    Build docker image located in `path`.

    Args:
        path: absolute path to directory where image located (e.g. /my_path/my_project/).
        tag: tag for docker image.
        dockerfile: name of the docker file. Default is Dockerfile
        rm: Remove intermediate containers.
            The docker build command now defaults to --rm=true.
            We have kept the old default of False for compatibility.
    """
    image, _ = client.images.build(path=path, tag=tag, rm=rm, dockerfile=dockerfile)
    result = {
        'image': {'id': image.id, 'tag': image.tags},
    }
    logger.debug(f'Built docker image: {result}')
    return result


def run_docker_container(
    image_name: str,
    auto_remove: bool = False,
    name: str | None = None,
) -> dict[str, Any]:
    """
    Run Docker container with specified image name.

    Args:
        image_name: tag specified while building container.
        auto_remove: enable auto-removal of the container
            on daemon side when the container's process exits.
        name: name for container. Default is None and will be generated by Docker
    """
    container = client.containers.run(
        image=image_name,
        auto_remove=auto_remove,
        detach=True,
        name=name,
    )
    result = {
        'container': {
            'name': container.name,
            'id': container.id,
            'health': container.health,
        }
    }
    logger.debug(f'Run docker container: {result}')
    return result


def stop_docker_container(container_id: str) -> dict[str, Any]:
    """
    Stop running docker container by its ID

    Args:
        container_id: ID of the container (e.g. 793fbb41814b)
    """
    result = {'container_id': container_id, 'success': True, 'msg': 'Successfully stopped'}
    try:
        container = client.containers.get(container_id)
        logger.debug(f'Stop container: {container}')
        container.stop()
    except docker.errors.NotFound:
        result['success'] = False
        result['msg'] = 'Container not found'
    logger.debug(f'Stop container result: {result}')
    return result


def run_docker_compose(path: str, services: list[str] | None = None, build: bool = False):
    """
    Runs containers located in docker-compose.yaml file located at the end of `path`.

    Args:
        path: aboslute path to docker compose file (e.g. /my/path/docker-compose.yaml).
        services: name of the services to run. Default is All
        build: --build flag that builds image
    """
    result = {'success': True, 'msg': 'Containers now running!'}
    specified_services: str = '' if not services else ' '.join(services)
    build_flag = '' if build is False else '--build'
    command = f'docker compose -f {path} up {specified_services} {build_flag} -d'
    logger.debug(f'Run docker compose commad: {command}')
    try:
        info = subprocess.run(command, shell=True, capture_output=True, text=True, check=True)
        logger.debug(f'Run docker compose result: {info.stdout}')
    except subprocess.CalledProcessError as e:
        logger.error(f'Error occured while running docker containers: {e}')
        result['success'] = False
        result['msg'] = str(e)
    return result


def stop_docker_compose(path: str):
    """
    Stop containers defined in docker compose file located at the end of `path`.

    Args:
        path: aboslute path to docker compose file (e.g. /my/path/docker-compose.yaml).
    """
    result = {'success': True, 'msg': 'Containers now running!'}
    command = f'docker compose -f {path} down'
    logger.debug(f'Stop docker compose command: {command}')
    try:
        info = subprocess.run(command, shell=True, capture_output=True, text=True, check=True)
        logger.debug(f'Stop docker compose result: {info.stdout}')
    except subprocess.CalledProcessError as e:
        logger.error(f'Error occured while stopping docker containers: {e}')
        result['msg'] = str(e)
        result['success'] = False
    return result


DOCKER_TOOLS = [
    tool(f, parse_docstring=True) for f in (
        list_docker_containers,
        build_docker_image,
        run_docker_container,
        stop_docker_container,
        run_docker_compose,
        stop_docker_compose,
    )
]
